<html>
<head>
<title>rozvoj.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(0,0,128); font-weight: bold; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(0,0,255); }
.s3 { color: rgb(128,128,128); font-style: italic; }
.s4 { color: rgb(0,128,128); font-weight: bold; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
rozvoj.py</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np 
</span><span class="s0">import </span><span class="s1">sympy </span><span class="s0">as </span><span class="s1">sp 
 
</span><span class="s0">from </span><span class="s1">sympy.abc </span><span class="s0">import </span><span class="s1">x 
 
EPS = </span><span class="s2">9e-17</span><span class="s1"> 
MALO = </span><span class="s2">2e-8</span><span class="s1"> 
 
 
</span><span class="s0">class </span><span class="s1">Soustava(object): 
    </span><span class="s3">&quot;&quot;&quot;třída Soustava&quot;&quot;&quot;</span><span class="s1"> 
    </span><span class="s4">&quot;&quot;&quot;pro zadanou fci, levý kraj a sgn báze vypočte bázi, ...&quot;&quot;&quot;</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self, fce=</span><span class="s4">'x**3-x**2-x-1'</span><span class="s1">, znamenko=</span><span class="s2">1</span><span class="s1">, levy_kraj=</span><span class="s4">'-x/3'</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;funkce, která se zavolá sama, jakmile vytvořím instanci třídy Soustava, v rámci dané instance si uloží znaménko, bázi, levý kraj, rozvoje&quot;&quot;&quot;</span><span class="s1"> 
        self.fce = fce 
        </span><span class="s0">if </span><span class="s1">(znamenko != </span><span class="s2">1</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(znamenko != -</span><span class="s2">1</span><span class="s1">): 
            </span><span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Báze může být kladná s hodnotou 1 nebo záporná s hodnotou -1.&quot;</span><span class="s1">) 
        self.znamenko = znamenko 
        self.spocitej_bazi_beta() 
        self.vycisleni_leveho_kraje(levy_kraj) 
        self.nalezeni_rozvoje_leveho_kraje() 
        self.nalezeni_rozvoje_praveho_kraje() 
 
    </span><span class="s0">def </span><span class="s1">spocitej_bazi_beta(self): 
        </span><span class="s3">&quot;&quot;&quot;tato funkce je zavolaná v __init__, pro danou rovnici spočte bázi, se kterou budeme počítat a uloží si ji&quot;&quot;&quot;</span><span class="s1"> 
        reseni = sp.solve(self.fce, x) 
        polebazi = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">reseni </span><span class="s0">if </span><span class="s1">np.isreal(np.complex(i))] 
        </span><span class="s0">if </span><span class="s1">len(polebazi) &lt; </span><span class="s2">1</span><span class="s1">: 
            </span><span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Špatně zvolená rovnice. Rovnice musí mít alespoň jeden reálný kořen.&quot;</span><span class="s1">) 
        </span><span class="s3"># Máme ověřeno, že polebazi[0] je největší?</span><span class="s1"> 
        baze = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">polebazi </span><span class="s0">if </span><span class="s1">i &gt; </span><span class="s2">1</span><span class="s1">] 
        </span><span class="s0">if </span><span class="s1">len(baze) != </span><span class="s2">1</span><span class="s1">: 
            </span><span class="s0">raise </span><span class="s1">ValueError( 
                </span><span class="s4">&quot;Bázi je nutno volit tak, aby měla jeden reálný kořen větší jak 1. Špatně zvolená rovnice.&quot;</span><span class="s1">) 
        self.beta = baze[</span><span class="s2">0</span><span class="s1">] 
 
    </span><span class="s0">def </span><span class="s1">vycisleni_leveho_kraje(self, levy_kraj): 
        </span><span class="s3">&quot;&quot;&quot;funkce, která pro levý kraj, jak symbolický vyjádřený pomocí bety(x), tak hodnotu, zjistí, zda splňuje námi požadované podmínky a přiřadí ho do proměnné&quot;&quot;&quot;</span><span class="s1"> 
        symbolicky_levy_kraj = sp.sympify(levy_kraj) 
        kraj = sp.N(symbolicky_levy_kraj.subs({x: self.beta})) 
        print(kraj) 
        </span><span class="s0">if </span><span class="s1">(kraj &gt; </span><span class="s2">0</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(kraj &lt; -</span><span class="s2">1</span><span class="s1">): 
            </span><span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Nejsou splněny základní požadavky, nula neleží v zadaném intervalu.&quot;</span><span class="s1">) 
        </span><span class="s0">if </span><span class="s1">(self.znamenko == -</span><span class="s2">1</span><span class="s1">) </span><span class="s0">and </span><span class="s1">((-kraj / self.beta - EPS &gt; (kraj + </span><span class="s2">1</span><span class="s1">)) </span><span class="s0">or </span><span class="s1">-(kraj + </span><span class="s2">1</span><span class="s1">) / self.beta + EPS &lt; kraj): 
            </span><span class="s3"># Je tu snížená přesnost čísel, tedy neporovnávám úplně ty dvě čísla, protože jsem měla problémy u -beta/(beta+1)</span><span class="s1"> 
            </span><span class="s3"># if (self.znamenko == -1) and ((-self.beta/(self.beta+1) &gt;= kraj) or (-1/(self.beta+1)&lt;kraj)):</span><span class="s1"> 
            </span><span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Nejsou splněny základní požadavky, interval není invariantní vůči posunutí.&quot;</span><span class="s1">) 
        self.levy_kraj = symbolicky_levy_kraj 
        self.pravy_kraj = symbolicky_levy_kraj + </span><span class="s2">1 </span><span class="s1">- EPS 
 
    </span><span class="s0">def </span><span class="s1">nalezeni_rozvoje_leveho_kraje(self, pocet_cifer=</span><span class="s2">30</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;tato funkce vytvoří instanci třídy Rozvoj, v rámci níž spočte rozvoj levého kraje a jeho periodu&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3"># tyto hodnoty lze pak nalézt v self.rozvoj_leveho_kraje.rozvoj_bodu a self.rozvoj_leveho_kraje.perioda&quot;&quot;&quot;</span><span class="s1"> 
        self.rozvoj_leveho_kraje = Rozvoj(self.beta, self.levy_kraj, self.levy_kraj, self.znamenko, </span><span class="s0">True</span><span class="s1">, pocet_cifer) 
 
    </span><span class="s0">def </span><span class="s1">nalezeni_rozvoje_praveho_kraje(self, pocet_cifer=</span><span class="s2">30</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;tato funkce vytvoří instanci třídy Rozvoj, v rámci níž spočte rozvoj pravého kraje a jeho periodu&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3"># tyto hodnoty lze pak nalézt v self.rozvoj_leveho_kraje.rozvoj_bodu a self.rozvoj_leveho_kraje.perioda&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3"># hodnota pravého kraje je levý kraj + 1 - EPS</span><span class="s1"> 
        self.rozvoj_praveho_kraje = Rozvoj(self.beta, self.pravy_kraj, self.levy_kraj, self.znamenko, </span><span class="s0">True</span><span class="s1">, pocet_cifer) 
 
    </span><span class="s0">def </span><span class="s1">prilep_periodu(self, retezec, perioda, delka_retezce): 
        </span><span class="s3">&quot;&quot;&quot;pomocná funkce, která k retezci v případě periody přilepí periodu tolikrát, aby délka řetězce byla rovna delka_retezce&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3"># v případě, že rětezec nemá periodu, mu přilepí tolik 0, aby jeho délka byla rovna delka_retezce</span><span class="s1"> 
        delka = len(retezec) 
        </span><span class="s0">if </span><span class="s1">(perioda </span><span class="s0">is None</span><span class="s1">): 
            pridam_nuly = [</span><span class="s2">0</span><span class="s1">] * (delka_retezce - delka) 
            retezec.extend(pridam_nuly) 
        </span><span class="s0">else</span><span class="s1">: 
            perioda_retezce = retezec[-perioda:] 
            pridam_periodu = (delka_retezce - delka) // perioda + </span><span class="s2">1</span><span class="s1"> 
            prodlouzeni = perioda_retezce * pridam_periodu 
            retezec.extend(prodlouzeni) 
            useknu = len(retezec) - delka_retezce 
            retezec = retezec[:-useknu] 
        </span><span class="s0">return </span><span class="s1">retezec 
 
    </span><span class="s0">def </span><span class="s1">porovnej_retezce(self, prvni_retezec, druhy_retezec, perioda_prvniho, perioda_druheho): 
        </span><span class="s3">&quot;&quot;&quot;Funkce, která dokáže porovnat dva řetězce i různé délky&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s3"># vrátí výsledek: -1: prvni_retezec &lt; druhy_retezec</span><span class="s1"> 
        </span><span class="s3">#                  1: prvni_retezec &gt; druhy_retezec</span><span class="s1"> 
        </span><span class="s3">#                  0: prvni_retezec = druhy_retezec</span><span class="s1"> 
        </span><span class="s3"># POZOR - nutno se trochu zamyslet, jak je to v případě dvou periodických řetězců, jde to</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">(perioda_prvniho </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(perioda_druheho </span><span class="s0">is not None</span><span class="s1">): 
            </span><span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;V současnosti neumíme a neporovnáváme dva řetězce s periodou!&quot;</span><span class="s1">) 
        </span><span class="s3"># Nyní zjistíme, který z řetězců je periodický</span><span class="s1"> 
        pracovni_retezec_1 = prvni_retezec.copy() 
        pracovni_retezec_2 = druhy_retezec.copy() 
        </span><span class="s0">if </span><span class="s1">(perioda_prvniho </span><span class="s0">is not None</span><span class="s1">): 
            pridam_nuly = [</span><span class="s2">0</span><span class="s1">] * perioda_prvniho 
            pracovni_retezec_2.extend(pridam_nuly) 
        </span><span class="s0">if </span><span class="s1">(perioda_druheho </span><span class="s0">is not None</span><span class="s1">): 
            pridam_nuly = [</span><span class="s2">0</span><span class="s1">] * perioda_druheho 
            pracovni_retezec_1.extend(pridam_nuly) 
        </span><span class="s3"># delka_prvniho = len(pracovni_retezec_1)</span><span class="s1"> 
        </span><span class="s3"># delka_druheho = len(pracovni_retezec_2)</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">len(pracovni_retezec_1) &gt; len(pracovni_retezec_2): 
            pracovni_retezec_2 = self.prilep_periodu(pracovni_retezec_2, perioda_druheho, len(pracovni_retezec_1)) 
        </span><span class="s0">elif </span><span class="s1">len(pracovni_retezec_2) &gt; len(pracovni_retezec_1): 
            pracovni_retezec_1 = self.prilep_periodu(pracovni_retezec_1, perioda_prvniho, len(pracovni_retezec_2)) 
        </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(pracovni_retezec_1)): 
            </span><span class="s0">if </span><span class="s1">(self.znamenko) ** (i + </span><span class="s2">1</span><span class="s1">) * pracovni_retezec_1[i] &lt; (self.znamenko) ** (i + </span><span class="s2">1</span><span class="s1">) * pracovni_retezec_2[i]: 
                </span><span class="s0">return </span><span class="s1">-</span><span class="s2">1  </span><span class="s3"># prvni retezec je MENSI jak druhy retezec</span><span class="s1"> 
            </span><span class="s0">elif </span><span class="s1">(self.znamenko) ** (i + </span><span class="s2">1</span><span class="s1">) * pracovni_retezec_1[i] \ 
                    &gt; (self.znamenko) ** (i + </span><span class="s2">1</span><span class="s1">) * pracovni_retezec_2[i]: 
                </span><span class="s0">return </span><span class="s2">1  </span><span class="s3"># prvni retezec je VETSI jak druhy retezec</span><span class="s1"> 
        </span><span class="s0">return </span><span class="s2">0  </span><span class="s3"># retezce se rovnaji</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">je_retezec_zleva_pripustny(self, retezec, perioda_retezce): 
        </span><span class="s3">&quot;&quot;&quot;funkce, která zjistí, zda je retezec a libovolný jeho sufix &gt;= rozvoj_leveho_kraje.rozvoj_bodu&quot;&quot;&quot;</span><span class="s1"> 
        pracovni_retezec = retezec.copy() 
        </span><span class="s3"># if len(pracovni_retezec)&gt; len(self.rozvoj_leveho_kraje.rozvoj_bodu):</span><span class="s1"> 
        </span><span class="s3"># delka_kraje = len(self.rozvoj_leveho_kraje)</span><span class="s1"> 
        </span><span class="s0">while </span><span class="s1">len(pracovni_retezec) &gt; </span><span class="s2">0</span><span class="s1">: 
            </span><span class="s0">if </span><span class="s1">self.porovnej_retezce(self.rozvoj_leveho_kraje.rozvoj_bodu, pracovni_retezec, 
                                     self.rozvoj_leveho_kraje.perioda, perioda_retezce) &gt; </span><span class="s2">0</span><span class="s1">: 
                </span><span class="s0">return False</span><span class="s1"> 
            pracovni_retezec.pop(</span><span class="s2">0</span><span class="s1">) 
        </span><span class="s0">return True</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">je_retezec_zprava_pripustny(self, retezec, perioda_retezce): 
        </span><span class="s3">&quot;&quot;&quot;funkce, která zjistí, zda je retezec a libovolný jeho sufix &lt; rozvoj_praveho_kraje.rozvoj_bodu&quot;&quot;&quot;</span><span class="s1"> 
        pracovni_retezec = retezec.copy() 
        </span><span class="s0">while </span><span class="s1">len(pracovni_retezec) &gt; </span><span class="s2">0</span><span class="s1">: 
            </span><span class="s0">if </span><span class="s1">self.porovnej_retezce(pracovni_retezec, self.rozvoj_praveho_kraje.rozvoj_bodu, perioda_retezce, 
                                     self.rozvoj_praveho_kraje.perioda) &gt;= </span><span class="s2">0</span><span class="s1">: 
                </span><span class="s0">return False</span><span class="s1"> 
            pracovni_retezec.pop(</span><span class="s2">0</span><span class="s1">) 
        </span><span class="s0">return True</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">je_retezec_pripustny(self, retezec, perioda_retezce): 
        </span><span class="s3">&quot;&quot;&quot;funkce, která spojuje fce je_retezec_zleva_pripustny a fci je_retezec_zprava_pripustny a určuje, zda je retezec připustný&quot;&quot;&quot;</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">self.je_retezec_zprava_pripustny(retezec, perioda_retezce) \ 
                </span><span class="s0">and </span><span class="s1">self.je_retezec_zleva_pripustny(retezec, perioda_retezce): 
            </span><span class="s0">return True</span><span class="s1"> 
        </span><span class="s0">else</span><span class="s1">: 
            </span><span class="s0">return False</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">vytvoreni_mink_maxk(self, k): 
        </span><span class="s3">&quot;&quot;&quot;na funkci se pracuje, měla by pro dané k nalézt řetězce mink a maxk &quot;&quot;&quot;</span><span class="s1"> 
        mink = list() 
        maxk = list() 
        min0 = [] 
        max0 = [] 
        mink.append(min0) 
        maxk.append(max0) 
        </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">1</span><span class="s1">, k): 
            mini = self.prilep_periodu(self.rozvoj_leveho_kraje.rozvoj_bodu, self.rozvoj_leveho_kraje.perioda, i) 
            maxi = self.prilep_periodu(self.rozvoj_praveho_kraje.rozvoj_bodu, self.rozvoj_praveho_kraje.perioda, i) 
            </span><span class="s3"># print(mini)</span><span class="s1"> 
            mk = </span><span class="s2">0</span><span class="s1"> 
            </span><span class="s0">while </span><span class="s1">mk &lt; i - </span><span class="s2">1</span><span class="s1">: 
                min_prefix = mini[:i - mk - </span><span class="s2">1</span><span class="s1">]  </span><span class="s3"># neměnný prefix</span><span class="s1"> 
                max_prefix = maxi[:i - mk - </span><span class="s2">1</span><span class="s1">] 
                </span><span class="s3"># print(i-mk)</span><span class="s1"> 
                </span><span class="s3"># print(mini)</span><span class="s1"> 
                min_cifra = mini[i - mk - </span><span class="s2">1</span><span class="s1">]  </span><span class="s3"># měnící se cifra</span><span class="s1"> 
                max_cifra = maxi[i - mk - </span><span class="s2">1</span><span class="s1">] 
                mozne_min1 = list() 
                mozne_max1 = list() 
                mozne_min1.extend(min_prefix) 
                mozne_max1.extend(max_prefix) 
                </span><span class="s0">if </span><span class="s1">(i - mk) % </span><span class="s2">2 </span><span class="s1">== </span><span class="s2">0 </span><span class="s0">or </span><span class="s1">self.znamenko == </span><span class="s2">1</span><span class="s1">:  </span><span class="s3"># sude</span><span class="s1"> 
                    </span><span class="s3"># mozne_min1.extend(min_prefix)</span><span class="s1"> 
                    mozne_min1.append(min_cifra + </span><span class="s2">1</span><span class="s1">) 
                    mozne_min1.extend(mink[mk]) 
                    </span><span class="s3"># mozne_max1.extend(max_prefix)</span><span class="s1"> 
                    mozne_max1.append(max_cifra - </span><span class="s2">1</span><span class="s1">) 
                    mozne_max1.extend(maxk[mk]) 
                </span><span class="s0">else</span><span class="s1">: 
                    mozne_min1.append(min_cifra - </span><span class="s2">1</span><span class="s1">) 
                    mozne_min1.extend(maxk[mk]) 
                    mozne_max1.append(max_cifra + </span><span class="s2">1</span><span class="s1">) 
                    mozne_max1.extend(mink[mk]) 
                </span><span class="s3"># print(mozne_min1)</span><span class="s1"> 
                </span><span class="s3"># if self.porovnej_retezce(mini,mozne_min1,None,None)</span><span class="s1"> 
                </span><span class="s0">if </span><span class="s1">self.je_retezec_pripustny(mozne_min1, </span><span class="s0">None</span><span class="s1">): 
                    </span><span class="s0">if </span><span class="s1">self.porovnej_retezce(mini, mozne_min1, </span><span class="s0">None</span><span class="s1">, </span><span class="s0">None</span><span class="s1">) == </span><span class="s2">1</span><span class="s1">: 
                        mini = mozne_min1 
                    </span><span class="s0">if not </span><span class="s1">self.je_retezec_pripustny(mini, </span><span class="s0">None</span><span class="s1">): 
                        mini = mozne_min1 
                </span><span class="s0">if </span><span class="s1">self.je_retezec_pripustny(mozne_max1, </span><span class="s0">None</span><span class="s1">): 
                    </span><span class="s0">if </span><span class="s1">self.porovnej_retezce(maxi, mozne_max1, </span><span class="s0">None</span><span class="s1">, </span><span class="s0">None</span><span class="s1">) == -</span><span class="s2">1</span><span class="s1">: 
                        maxi = mozne_max1 
                    </span><span class="s0">if not </span><span class="s1">self.je_retezec_pripustny(maxi, </span><span class="s0">None</span><span class="s1">): 
                        maxi = mozne_max1 
                mk += </span><span class="s2">1</span><span class="s1"> 
            mink.append(mini) 
            maxk.append(maxi) 
        self.mink = mink 
        self.maxk = maxk 
 
    </span><span class="s0">def </span><span class="s1">gamma_funkce(self, retezec): 
        gamma = </span><span class="s2">0</span><span class="s1"> 
        obraceny_retezec = retezec[::-</span><span class="s2">1</span><span class="s1">] 
        </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(retezec)): 
            gamma += (self.znamenko * self.beta) ** i * obraceny_retezec[i] 
        </span><span class="s0">return </span><span class="s1">sp.N(gamma,n=</span><span class="s2">20</span><span class="s1">) 
 
    </span><span class="s0">def </span><span class="s1">spocteni_vzdalenosti(self,k): 
        delta=list() 
        </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(k): 
            </span><span class="s3">#print(self.mink[i])</span><span class="s1"> 
            </span><span class="s3">#print(self.gamma_funkce(self.mink[i]))</span><span class="s1"> 
            vzdalenost=sp.N(abs((self.znamenko*self.beta)**i + self.gamma_funkce(self.mink[i])-self.gamma_funkce(self.maxk[i])), n=</span><span class="s2">20</span><span class="s1">) 
            delta.append(vzdalenost) 
        self.delta=delta 
 
 
</span><span class="s0">class </span><span class="s1">Rozvoj(object): 
    </span><span class="s3">'''Třída pro rozvoj libovolného čísla v intervalu &lt;l,l+1), nutno znát kladnou/zápornou (znaménko) bázi beta, bod, l, a počet cifer'''</span><span class="s1"> 
 
    </span><span class="s0">def </span><span class="s1">__init__(self, baze, bod, levy_kraj, znamenko=</span><span class="s2">1</span><span class="s1">, symbolicke=</span><span class="s0">False</span><span class="s1">, pocet_cifer=</span><span class="s2">30</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;funkce, která se spustí automaticky s vytvořením instance Rozvoj, uloží si jednotlivé hodnoty a spočte rozvoj bodu s jeho periodou&quot;&quot;&quot;</span><span class="s1"> 
        self.baze = baze 
        self.znamenko = znamenko 
        self.levy_kraj = levy_kraj 
        </span><span class="s0">if </span><span class="s1">symbolicke: 
            symbolicky_bod = sp.sympify(bod) 
            self.bod = sp.N(symbolicky_bod.subs({x: self.baze}), n=</span><span class="s2">40</span><span class="s1">)  </span><span class="s3"># přesnost</span><span class="s1"> 
        </span><span class="s0">else</span><span class="s1">: 
            self.bod = bod 
        self.perioda = </span><span class="s0">None</span><span class="s1"> 
        self.rozvoj_bodu = </span><span class="s0">None</span><span class="s1"> 
        </span><span class="s3"># self.nalezeni_rozvoje(pocet_cifer)</span><span class="s1"> 
        </span><span class="s3"># self.perioda2 = None</span><span class="s1"> 
        </span><span class="s3"># self.rozvoj_bodu2 = None</span><span class="s1"> 
        self.nalezeni_rozvoje2(pocet_cifer) 
 
    </span><span class="s0">def </span><span class="s1">nalezeni_rozvoje(self, pocet_cifer=</span><span class="s2">30</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;pomocná funkce, která pro zadaný bod spočte rozvoj_bodu v dané bázi na pocet_cifer&quot;&quot;&quot;</span><span class="s1"> 
        perioda = </span><span class="s0">False</span><span class="s1"> 
        iterace = list() 
        rozvoj = list() 
        iterace.append(self.bod) 
        i = </span><span class="s2">1</span><span class="s1"> 
        </span><span class="s0">while </span><span class="s1">(</span><span class="s0">not </span><span class="s1">perioda) </span><span class="s0">and </span><span class="s1">(i &lt; pocet_cifer): 
            transformace = self.znamenko * self.baze * iterace[i - </span><span class="s2">1</span><span class="s1">] - self.levy_kraj 
            iterace.append( 
                sp.N(self.znamenko * self.baze * iterace[i - </span><span class="s2">1</span><span class="s1">] - sp.floor(transformace).subs({x: self.baze}), 
                     n=</span><span class="s2">40</span><span class="s1">))  </span><span class="s3"># n určuje přesnost vyčíslení</span><span class="s1"> 
            </span><span class="s3"># print(sp.N(transformace.subs({x: self.baze}), n=30))</span><span class="s1"> 
            rozvoj.append(sp.floor(sp.N(transformace.subs({x: self.baze}), n=</span><span class="s2">30</span><span class="s1">))) 
            </span><span class="s3"># POZOR - nutno nějak zapracovat s přesností, ještě to dost zlobí, někde je asi chyba...</span><span class="s1"> 
            </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(len(iterace)): 
                </span><span class="s0">if </span><span class="s1">(abs(iterace[j] - iterace[i]) &lt; MALO) </span><span class="s0">and </span><span class="s1">(j != i): 
                    perioda = </span><span class="s0">True</span><span class="s1"> 
                    self.perioda = i - j 
            i += </span><span class="s2">1</span><span class="s1"> 
        print(iterace) 
        self.rozvoj_bodu = rozvoj 
 
    </span><span class="s0">def </span><span class="s1">nalezeni_rozvoje2(self, pocet_cifer=</span><span class="s2">30</span><span class="s1">): 
        </span><span class="s3">&quot;&quot;&quot;pomocná funkce, která pro zadaný bod spočte rozvoj_bodu v dané bázi na pocet_cifer&quot;&quot;&quot;</span><span class="s1"> 
        perioda = </span><span class="s0">False</span><span class="s1"> 
        transformace = list() 
        rozvoj = list() 
        transformace.append(self.bod) 
        i = </span><span class="s2">1</span><span class="s1"> 
        </span><span class="s0">while </span><span class="s1">(</span><span class="s0">not </span><span class="s1">perioda) </span><span class="s0">and </span><span class="s1">(i &lt; pocet_cifer): 
            cifra = self.znamenko * self.baze * transformace[i - </span><span class="s2">1</span><span class="s1">] - self.levy_kraj 
            rozvoj.append(sp.floor(sp.N(cifra.subs({x: self.baze}), n=</span><span class="s2">30</span><span class="s1">))) 
            nova_transformace = self.znamenko * self.baze * transformace[i - </span><span class="s2">1</span><span class="s1">] - rozvoj[i - </span><span class="s2">1</span><span class="s1">] 
            transformace.append(sp.N(nova_transformace.subs({x: self.baze}), n=</span><span class="s2">40</span><span class="s1">)) 
            </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(len(transformace)): 
                </span><span class="s0">if </span><span class="s1">(abs(transformace[j] - transformace[i]) &lt; MALO) </span><span class="s0">and </span><span class="s1">(j != i): 
                    perioda = </span><span class="s0">True</span><span class="s1"> 
                    self.perioda = i - j 
            i += </span><span class="s2">1</span><span class="s1"> 
        </span><span class="s3"># print(transformace)</span><span class="s1"> 
        self.rozvoj_bodu = rozvoj 
</span></pre>
</body>
</html>